"
GtGemStoneSessionRegistry is a collection of named sessions, stored in a properties file.

The global (uniqueInstance) is maintained by Lepiter.
 
## Internal Representation and Key Implementation Points.

### Instance Variables
	propertiesFile:		<GtGemStonePropertiesFile>
	sessions:				<Dictionary>


### Implementation Points
"
Class {
	#name : #GtGemStoneSessionRegistry,
	#superclass : #Object,
	#traits : 'TGtUniqueInstance',
	#classTraits : 'TGtUniqueInstance classTrait',
	#instVars : [
		'propertiesFile',
		'sessions',
		'announcer',
		'connectors',
		'lastSessionId',
		'defaultName',
		'defaultSession',
		'keepAlive',
		'codeSync'
	],
	#classInstVars : [
		'uniqueInstance'
	],
	#category : #'GToolkit-GemStone-Pharo-Registry'
}

{ #category : #accessing }
GtGemStoneSessionRegistry class >> connectorNameFromSessionName: aString [
	"Answer the connector name from the supplied session name"

	^ (aString splitOn: $:) first
]

{ #category : #accessing }
GtGemStoneSessionRegistry class >> default [
	"Answer the default session registry, i.e. the properties file is co-located with the leptier logical database properties."

	self hasUniqueInstance ifTrue: [ ^ uniqueInstance ].

	uniqueInstance := self new 
		propertiesFilename: LeDatabasesRegistry defaultPrimaryDatabase 
			properties gemStonePropertiesFile.
	uniqueInstance ensureKeepAlive.
	^ uniqueInstance
]

{ #category : #accessing }
GtGemStoneSessionRegistry class >> defaultSession [
	^ self default defaultSession
]

{ #category : #initialization }
GtGemStoneSessionRegistry class >> initialize [ 
	"Reload the registry after lepiter has been notified of a session start"

	SessionManager default 
		registerUserClassNamed: self name
		atPriority: 120.

]

{ #category : #'private - hooks' }
GtGemStoneSessionRegistry class >> onRemoveUniqueInstance: anInstance [
	"Classes may perform some activities on a singleton that is about to be released"
	
	uniqueInstance ifNotNil: 
		[ uniqueInstance shutdown ].
]

{ #category : #accessing }
GtGemStoneSessionRegistry class >> sessionIdFromSessionName: aString [
	"Answer the session Id from the supplied session name"

	^ (aString splitOn: $:) second
]

{ #category : #'system startup' }
GtGemStoneSessionRegistry class >> startUp: resuming [

	self hasUniqueInstance ifTrue: [ uniqueInstance startUp: resuming ].

]

{ #category : #accessing }
GtGemStoneSessionRegistry >> activeSessionNames [
	"Answer the set of session names that have active (but not necessarily running) sessions"
	<return: #Array>

	^ sessions
		ifNil: [ #() ]
		ifNotNil: [ sessions keys ]
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> activeSessions [
	"Answer the set of session names that have active (but not necessarily running) sessions"
	<return: #Array>

	^ sessions
		ifNil: [ #() ]
		ifNotNil: [ sessions values ]
]

{ #category : #actions }
GtGemStoneSessionRegistry >> addNewConnector [ 
	| newConnector |

	newConnector := propertiesFile addNewConnector.
	self assert: (self connectors includesKey: newConnector name) not.
	newConnector registry: self.
	connectors at: newConnector name put: newConnector.
	^ newConnector
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> addSession: aSession named: aString [

	self sessions at: aString put: aSession
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> allConnectors [

	^ self connectors values
]

{ #category : #'api - announcer' }
GtGemStoneSessionRegistry >> announce: anAnnouncement [
	<generatedFrom: #'TGtRobocoderAnnouncerTemplate>>#announceTemplate'>
	announcer ifNotNil: [ :anAnnouncer | anAnnouncer announce: anAnnouncement ].
]

{ #category : #'api - announcer' }
GtGemStoneSessionRegistry >> announcer [
	^ announcer ifNil: [ announcer := Announcer new ]
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> availableConnectors [
	"Answer the known connectors"

	^ (self class allMethods 
		select: [ :method | method hasPragmaNamed: #gemstoneConnectors ]
		thenFlatCollect: [ :method | | theConnectors |
			theConnectors := self perform: method selector.
			theConnectors collect: [ :connector |
				"Connector names aren't allowed to include colons ($:)"
				self assert: (connector name indexOf: $:) = 0.
				connector registry: self.
				connector name -> connector ] ]) asDictionary.
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> cleanSessionWithConnectorNamed: aString [
	"Answer a clean session with the supplied connector name.
	Create the session if required."

	^ sessions
		detect: [ :each | 
			each connector name = aString
				and: [ each isRunning and: [ each needsCommit not ] ] ]
		ifNone: [ self newSessionWithConnectorNamed: aString ]
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> codeSync [
	^ codeSync
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> codeSync: aGtGemStoneCodeSync [

	codeSync := aGtGemStoneCodeSync.
	codeSync registry: self.
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> connectorNamed: aString [
	"Answer the connector at the supplied name"

	aString = GtGemStoneNullConnector connectorName ifTrue:
		[ ^ GtGemStoneNullConnector new ].

	^ self connectors at: aString
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> connectorNamed: aString ifPresent: presentBlock ifAbsent: absentBlock [
	"Answer the connector at the supplied name"

	aString = GtGemStoneNullConnector connectorName ifTrue:
		[ ^ GtGemStoneNullConnector new ].

	^ self connectors 
		at: aString
		ifPresent: presentBlock
		ifAbsent: absentBlock
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> connectorNames [ 
	"Answer the list of known session names"
	<return: #Array>

	^ self connectors keys asArray
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> connectors [
	"Answer the known connectors"

	^ connectors ifNil: [ connectors := self availableConnectors ].
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> defaultConnectorName [ 

	^ defaultName ifNil: [ propertiesFile 
		ifNil: [ GtGemStoneNullConnector connectorName ]
		ifNotNil: [ propertiesFile defaultConnectorName ] ]
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> defaultSession [

	^ defaultSession ifNil: 
		[ defaultSession := self
			sessionWithConnectorNamed: 'default'
			ifAbsent:
				[ self
					connectorNamed: 'default'
					ifPresent: [ :connector | 
						self newSessionWithConnectorNamed: 'default'  ]
					ifAbsent: [ nil ] ] ].
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> defaultSession: aGtGemStoneSession [

	defaultSession := aGtGemStoneSession.
	self announce: (GtGemStoneSessionDefaultAnnouncement session: defaultSession).
]

{ #category : #'keep alive' }
GtGemStoneSessionRegistry >> ensureKeepAlive [

	keepAlive ifNotNil: [ ^ self ].
	keepAlive := GtGemStoneSessionKeepAlive new
		registry: self;
		start.
]

{ #category : #ui }
GtGemStoneSessionRegistry >> gtAvailableConnectorsFor: aView [
	<gtView>

	^ aView columnedList
		title: 'Available connectors';
		priority: 50;
		items: [ self availableConnectors sorted: #name ascending ];
		column: 'Name' text: [ :item | item name ];
		column: 'Username' text: [ :item | item username ];
		column: 'Stone' text: [ :item | item stone ];
		actionUpdateButton
]

{ #category : #ui }
GtGemStoneSessionRegistry >> gtCodeSyncLogGroupedFor: aView [
	<gtView>

	codeSync ifNil: [ ^ aView empty ].
	^ aView forward
		title: 'Code Sync Log Grouped';
		priority: 44;
		object: [ codeSync ];
		view: #gtGroupedFor:
]

{ #category : #ui }
GtGemStoneSessionRegistry >> gtCodeSyncLogRecordsFor: aView [
	<gtView>

	codeSync ifNil: [ ^ aView empty ].
	^ aView forward
		title: 'Code Sync Log Records';
		priority: 45;
		object: [ codeSync ];
		view: #gtRecordingsFor:
]

{ #category : #ui }
GtGemStoneSessionRegistry >> gtCodeSyncSummaryFor: aView [
	<gtView>

	codeSync ifNil: [ ^ aView empty ].
	^ aView forward
		title: 'Code Sync';
		priority: 40;
		object: [ codeSync ];
		view: #gtStatusFor:
]

{ #category : #ui }
GtGemStoneSessionRegistry >> gtConnectorsFor: aView [
	<gtView>

	^ aView columnedList
		title: 'Connectors';
		priority: 20;
		items: [ self allConnectors sorted: #name ascending ];
		column: 'Name' text: [ :item | item name ];
		column: 'Username' text: [ :item | item username ];
		column: 'Stone' text: [ :item | item stone ];
		contextItemLabel: 'New Session' action: 
			[ :anElement :aGtGemStoneConnnector | aGtGemStoneConnnector registry newSessionWithConnector: aGtGemStoneConnnector ];
		actionUpdateButton
]

{ #category : #ui }
GtGemStoneSessionRegistry >> gtInspectKeepAliveFor: anAction [
	<gtAction>

	^ anAction button
		label: 'log';
		priority: 10;
		icon: BrGlamorousVectorIcons transcript;
		tooltip: 'Inspect KeepAlive log';
		action: [ :button |
			button phlow spawnObject: GtGemStoneKeepAliveCollector start ].
]

{ #category : #ui }
GtGemStoneSessionRegistry >> gtLiveFor: aView [
	<gtView>

	^ aView columnedList
		title: 'Sessions';
		priority: 10;
		items: [ sessions values sorted: #name ascending ];
		column: 'Name' 
			text: [ :aSession |
				aSession formatBasedOnStatusText: aSession name ];
		column: 'Status' 
			text: [ :aSession | 
				aSession formatBasedOnStatusText: aSession statusDescription ]
			width: 175;
		column: 'Default' icon: [ :aSession |
			aSession isDefaultSession
				ifTrue: [ BrGlamorousVectorIcons accept ]
				ifFalse: [ BrGlamorousVectorIcons noIcon ] ]
			width: 50;
		contextItemLabel: 'Playground' action:
			[ :anElement :aGtGemStoneSession | 
				self openPlaygroundOn: aGtGemStoneSession from: anElement ];
		contextItemLabel: 'Commit' 
			action: [ :anElement :aGtGemStoneSession | 
				aGtGemStoneSession commitTransaction.
				anElement phlow firstParentWithView phlow update ]
			if: [ :aGtGemStoneSession | aGtGemStoneSession isRunning ];
		contextItemLabel: 'Abort' 
			action: [ :anElement :aGtGemStoneSession | 
				aGtGemStoneSession abortTransaction.
				anElement phlow firstParentWithView phlow update ]
			if: [ :aGtGemStoneSession | aGtGemStoneSession isRunning ];
		contextItemLabel: 'Connect' 
			action:[ :anElement :aGtGemStoneSession | 
				aGtGemStoneSession connect.
				anElement phlow firstParentWithView phlow update ]
			if: [ :aGtGemStoneSession | aGtGemStoneSession isRunning not ];
		contextItemLabel: 'Disconnect' 
			action: [ :anElement :aGtGemStoneSession | 
				aGtGemStoneSession close.
				anElement phlow firstParentWithView phlow update ]
			if: [ :aGtGemStoneSession | aGtGemStoneSession isRunning ];
		contextItemLabel: 'Be Default' 
			action: [ :anElement :aGtGemStoneSession | 
				aGtGemStoneSession beDefaultSession.
				anElement phlow firstParentWithView phlow update ]
			if: [ :aSession | aSession isDefaultSession not ];
		contextItemLabel: 'Inspect' 
			action: [ :anElement :aGtGemStoneSession | 
				anElement phlow spawnObject: aGtGemStoneSession ];
		actionUpdateButton
]

{ #category : #ui }
GtGemStoneSessionRegistry >> gtStatusFor: aView [
	<gtView>

	^ aView columnedList
		title: 'Status';
		priority: 10;
		items: [ self statusAttributes ];
		column: #Attribute text: [ :item | item first ];
		column: #Value text: [ :item | | value |
				value := item second.
				value isBoolean ifTrue:
					[ value
						ifTrue: [ (Character value: 16r2713) asString ]
						ifFalse: [ '-' ] ]
				ifFalse:
					[ value ] ];
		send: [ :item | item third ];
		actionUpdateButton 
]

{ #category : #testing }
GtGemStoneSessionRegistry >> hasConnectorNamed: aString [
	"Answer a boolean indicating whether the receiver has the named connector"
	<return: #Boolean>

	^ self connectors includesKey: aString
]

{ #category : #testing }
GtGemStoneSessionRegistry >> hasConnectors [

	^ self connectors notEmpty
]

{ #category : #testing }
GtGemStoneSessionRegistry >> hasDefaultSession [

	^ defaultSession isNotNil
]

{ #category : #testing }
GtGemStoneSessionRegistry >> hasSessionNamed: aString [
	"Answer a boolean indicating whether the receiver has the named session"
	<return: #Boolean>

	^ sessions 
		ifNil: [ false ]
		ifNotNil: [ sessions includesKey: aString ]
]

{ #category : #testing }
GtGemStoneSessionRegistry >> hasSessions [

	^ sessions isNotEmpty
]

{ #category : #initialization }
GtGemStoneSessionRegistry >> initialize [

	super initialize.
	lastSessionId := 0.
	self reload "resetSessions".
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> newSessionNamed: aString [
	| connectorName sessionId |

	connectorName := self class connectorNameFromSessionName: aString.
	sessionId := self class sessionIdFromSessionName: aString.
	^ self newSessionWithConnector: (self connectorNamed: connectorName)
		id: sessionId
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> newSessionWithConnector: aGtGemStoneConnector [
	"Answer a new session using the supplied connector"

	^ (self newSessionWithConnector: aGtGemStoneConnector
		id: (lastSessionId := lastSessionId + 1) asString)
			connect.
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> newSessionWithConnector: aGtGemStoneConnector id: sessionId [
	"Answer a new session using the supplied connector"
	| newSession |

	self assert: (sessionId indexOf: $:) = 0.
	newSession := GtGemStoneSession new
		connector: aGtGemStoneConnector;
		sessionId: sessionId asString;
		registry: self.
	sessions at: newSession name put: newSession.
	self announce: (GtGemStoneSessionAddedAnnouncement session: newSession).
	sessions size = 1 ifTrue: [ self defaultSession: newSession ].
	^ newSession.
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> newSessionWithConnectorNamed: aString [
	"Answer a new session using the supplied connector name"

	^ self newSessionWithConnector: (self connectorNamed: aString)
]

{ #category : #private }
GtGemStoneSessionRegistry >> onConnectorAnnouncement: aGtGemStoneConnectorAnnouncement [
	"Propogate any announcements from the properties file.
	If the connector has been renamed, rebuild the session dictionary."
	| newSessions newConnectors |

	aGtGemStoneConnectorAnnouncement isNameChange ifTrue:
		[ newSessions := Dictionary new.
		sessions ifNotNil:
			[ sessions valuesDo: [ :session |
				newSessions at: session name put: session ] ].
		sessions := newSessions.
		connectors ifNotNil:
			[ newConnectors := Dictionary new.
			connectors valuesDo: [ :connector |
				newConnectors at: connector name put: connector ].
			connectors := newConnectors ] ].

	self announce: aGtGemStoneConnectorAnnouncement
]

{ #category : #ui }
GtGemStoneSessionRegistry >> openPlaygroundOn: aSession from: anElement [
	| page |

	page := LePage unnamedPage.
	page addSnippet: (LeGemStoneSnippet new sessionName: aSession name).
	LeDatabasesRegistry default defaultLogicalDatabase playgroundDB addPage: page.
	GtWorldUtility
		showSpaceWithTitle: aSession name
		inPagerWith: [ page asLepiterPagePhlowTool asElementDo: [ :e | e ] ]
				asStencil
		from: anElement
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> propertiesFile [

	^ propertiesFile
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> propertiesFile: aGtGemStonePropertiesFile [

	propertiesFile ifNotNil:
		[ propertiesFile unsubscribe: self ].
	propertiesFile := aGtGemStonePropertiesFile.
	propertiesFile
		when: GtGemStoneConnectorAnnouncement 
		send: #onConnectorAnnouncement:
		to: self.
	self resetConnectors.
	self resetSessions.
]

{ #category : #connectors }
GtGemStoneSessionRegistry >> propertiesFileConnectors [
	"Answer connectors specified in the properties file."
	<gemstoneConnectors>

	^ propertiesFile
		ifNil: [ #() ]
		ifNotNil: [ propertiesFile allConnectors ]
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> propertiesFilename [

	^ propertiesFile ifNotNil: [ propertiesFile file ]
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> propertiesFilename: aFileReference [
	"Open the registry's properties on the supplied file"

	(propertiesFile isNotNil and: [ 
		aFileReference = propertiesFile file ]) 
			ifTrue: [ ^ self ].
	self propertiesFile: (GtGemStonePropertiesFile file: aFileReference).
]

{ #category : #private }
GtGemStoneSessionRegistry >> reload [
	"Reload the properties file and reset the sessions"

	propertiesFile ifNotNil:
		[ propertiesFile := GtGemStonePropertiesFile file: self propertiesFilename ].
	self resetConnectors.
	self resetSessions.
]

{ #category : #removing }
GtGemStoneSessionRegistry >> removeConnector: aGtGemStoneConnector [
	"Remove the supplied connector from the properties file"

	self removeConnectorNamed: aGtGemStoneConnector name.
]

{ #category : #removing }
GtGemStoneSessionRegistry >> removeConnectorNamed: aString [
	"Remove the supplied connector from the receiver and its properties file."
	| removedConnector |
	
	removedConnector := connectors removeKey: aString.
	propertiesFile removeConnectorNamed: aString.
	removedConnector notifyRemoved.
]

{ #category : #removing }
GtGemStoneSessionRegistry >> removeSession: aGtGemStoneSession [
	"Remove the supplied session and its definition"

	aGtGemStoneSession close.
	sessions
		removeKey: aGtGemStoneSession name
		ifAbsent: [ ^ self ].
	self announce: (GtGemStoneSessionRemovedAnnouncement session: aGtGemStoneSession).
]

{ #category : #private }
GtGemStoneSessionRegistry >> resetConnectors [

	connectors := nil.
]

{ #category : #private }
GtGemStoneSessionRegistry >> resetSessions [ 

	sessions ifNotNil: [ sessions values do: #close ].
	sessions := Dictionary new.
	defaultSession := nil.
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> sessionNamed: aString [
	"Answer the session at the supplied name"

	^ sessions 
		at: aString
		ifAbsent: [ self newSessionNamed: aString ]
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> sessionNamed: aString ifAbsent: absentBlock [
	"Answer the session at the supplied name"

	sessions ifNil: [ ^ absentBlock value ].
	^ sessions at: aString ifAbsent: absentBlock
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> sessionWithConnection: aRsrConnection [
	<return: #GtGemStoneSession>

	^ sessions detect: [ :each |
		each connection = aRsrConnection ]
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> sessionWithConnection: aRsrConnection ifAbsent: absentBlock [
	<return: #GtGemStoneSession>

	^ sessions 
		detect: [ :each | each connection = aRsrConnection ]
		ifNone: absentBlock
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> sessionWithConnectorNamed: aString [
	"Answer a session with the supplied connector name.
	Create the session if required."

	^ (self sessions select: [ :each | each connector name = aString ])
		ifEmpty: [ self newSessionWithConnectorNamed: aString ]
		ifNotEmpty: [ :sessionCollection |
			(sessionCollection sorted: #sessionId ascending) first ].
]

{ #category : #accessing }
GtGemStoneSessionRegistry >> sessionWithConnectorNamed: aString ifAbsent: absentBlock [
	"Answer a session with the supplied connector name.
	Create the session if required."

	^ (self sessions select: [ :each | each connector name = aString ])
		ifEmpty: absentBlock
		ifNotEmpty: [ :sessionCollection |
			(sessionCollection sorted: #sessionId ascending) first ].
]

{ #category : #private }
GtGemStoneSessionRegistry >> sessions [ 

	^ sessions
]

{ #category : #initialization }
GtGemStoneSessionRegistry >> shutdown [

	self resetSessions.
	self stopKeepAlive.
	self stopCodeSync.
]

{ #category : #'system startup' }
GtGemStoneSessionRegistry >> startUp: isImageStarting [
	"A new Pharo session is being started, if this is a new image (from disk) reload the properties file"

	isImageStarting ifTrue: [ self reload ]
]

{ #category : #ui }
GtGemStoneSessionRegistry >> statusAttributes [

	^ Array streamContents: [ :stream |
		stream
			nextPut: { 'Code Sync.'. codeSync isNotNil. codeSync. };
			nextPut: { 'Keep Alive'. 
						keepAlive ifNotNil: 
							[ keepAlive isRunning
								ifTrue: [ true ]
								ifFalse: [ keepAlive status ] ]
						ifNil: 
							[ false ]. keepAlive. };
			nextPut: { 'Default Session'.
						self hasDefaultSession
							ifTrue: [ self defaultSession name ]
							ifFalse: [ false ]. 
						self hasDefaultSession
							ifTrue: [ self defaultSession ]
							ifFalse: [ nil ]. } ].

]

{ #category : #initialization }
GtGemStoneSessionRegistry >> stopCodeSync [

	codeSync ifNotNil:
		[ codeSync stop.
		codeSync := nil ]
]

{ #category : #'keep alive' }
GtGemStoneSessionRegistry >> stopKeepAlive [

	keepAlive ifNil: [ ^ self ].
	keepAlive stop.
	keepAlive := nil.
]

{ #category : #'api - announcer' }
GtGemStoneSessionRegistry >> unsubscribe: anObject [
	"Unsubscribe all subscriptions of anObject from the receiver"

	<generatedFrom: #'TGtRobocoderAnnouncerTemplate>>#unsubscribeTemplate'>
	^ announcer ifNotNil: [ :anAnnouncer | anAnnouncer unsubscribe: anObject ]
]

{ #category : #'api - announcer' }
GtGemStoneSessionRegistry >> when: anAnnouncementClass do: aBlock [
	<generatedFrom: #'TGtRobocoderAnnouncerTemplate>>#whenDoTemplate'>
	^ (announcer ifNil: [ announcer := Announcer new ])
		when: anAnnouncementClass do: aBlock
]

{ #category : #'api - announcer' }
GtGemStoneSessionRegistry >> when: anAnnouncementClass do: aBlock for: aSubscriber [
	<generatedFrom: #'TGtRobocoderAnnouncerTemplate>>#whenDoForTemplate'>
	^ (self when: anAnnouncementClass do: aBlock)
		subscriber: aSubscriber;
		yourself
]

{ #category : #'api - announcer' }
GtGemStoneSessionRegistry >> when: anAnnouncementClass send: aSelector to: anObject [
	<generatedFrom: #'TGtRobocoderAnnouncerTemplate>>#whenSendToTemplate'>
	^ (announcer ifNil: [ announcer := Announcer new ]) weak
		when: anAnnouncementClass send: aSelector to: anObject
]
